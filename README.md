# **lesson 28**
### ВОПРОСЫ И ЗАДАНИЯ

#### 1) 

Для сложения двух положительных целых чисел, записанных в 8-разрядные ячейки, нужно сложить соответствующие разряды столбиком, начиная с младшего разряда. Если в полученной сумме есть разряд, который больше 1, то в текущий разряд результата записывается последняя цифра этой суммы, а в следующий разряд переносится 1.

Пример:

![cnjk,br](https://github.com/user-attachments/assets/9ea3b87b-4bda-4a51-a753-231a8816de52)


#### 2) 

Дополнительный код – это система для представления знаковых чисел, упрощающая двоичную арифметику. Для нахождения дополнительного кодадвоичного числа мы инвертируем все его биты (изменяя 0 на 1 и 1 на 0), а затем прибавляем к результату 1. Это представление упрощает проектирование компьютеров, позволяя выполнять сложение и вычитание на одной схеме, поскольку вычитание числа равнозначно прибавлению его дополнительного кода. 

#### 3)

Переполнение может возникнуть при следующих комбинациях знаков слагаемых в результате сложения: 

 1 А и В положительные, сумма А+В больше либо равна 2n-1, где n — количество разрядов формата чисел (для однобайтового формата n=8, 2n-1 = 27 = 128). 
 
 2 А и В отрицательные, сумма абсолютных величин А и В больше либо равна 2n-1. 
 
Для обнаружения переполнения и оповещения о возникшей ошибке в компьютере используются специальные средства. 

#### 4) 

Хардовый суммато́р 

Целочисленные операции сложения и вычитания в компьютере реализуются хардовым сумматором, который входит в состав АЛУ любого процессора.

#### 5) 

Специального устройства для вычитания целых чисел не требуется, поскольку операция вычитания выполняется путем выполнения сложения в дополнительном коде. 

#### 6) 

Чтобы перемножить два положительных целых числа в двоичной системе счисления, мы используем алгоритм умножения столбиком. Изменение знака одного из сомножителей не влияет на алгоритм выполнения операции умножения. 

#### 7) 

Коды чисел со знаком и без знака нужно сравнивать по-разному, потому что представление чисел со знаком включает в себя дополнительный разряд, представляющий знак числа. При сравнении кодов чисел со знаком, мы должны учитывать их знаки, чтобы определить, какое число больше. 

#### 8) 

Поразрядные операции — это операции, которые проводятся только над соответствующими разрядами целочисленных операндов. 

#### 9) 

Арифметические операции в позиционных системах счисления с основанием q выполняются по правилам, аналогичным правилам, действующим в десятичной системе счисления.

#### 10) 

Маска подсети — это 32-битное число, которое указывает, какая часть IP-адреса относится к сети, а какая — к устройствам (хостам), находящимся в этой сети. 

#### 11) 

Чтобы сбросить определенный бит в числе с использованием маски, мы можем использовать операцию "И" с инвертированной маской. Для сброса бита на позиции n мы должны создать маску, где все биты, кроме бита на позиции n, установлены в 1, а бит на позиции n установлен в 0. 
 
Например, если нам нужно сбросить бит на позиции 3 в числе x, мы можем использовать следующую маску: ~(1 << 3), где << обозначает сдвиг влево. Эта операция создаст число со всеми битами, кроме 3-го, установленными в 1, а 3-й бит будет установлен в 0. Затем мы применяем операцию "И" к числу x и этой маске: x = x & ~(1 << 3). 

#### 12) 

11111111111111100 — маска для сброса 2 младших бит в 16-разрядном числе.  

Для сброса используется операция И 

#### 13) 

Чтобы установить определённый бит с помощью битовой маски, можно использовать побитовый оператор OR и побитовый оператор сдвига влево. 
Сначала нужно сдвинуть бит LSB, равный 1, в указанное положение, которое нужно установить, а затем выполнить побитовую операцию OR. 

#### 14) 

Для того чтобы установить 2 старших бита в 16-разрядном числе, не изменяя все остальные, нужно использовать маску со значением 0xC000. Для этого мы устанавливаем нужные биты в 1, а остальные биты в 0, и применяем операцию "ИЛИ" с исходным числом. 

#### 15) 

Для определения, делится ли число на 4 или на 8, можно использовать логические операции. Если число делится на 4, то его младшие два бита должны быть равны 0. Если число делится на 8, то младшие три бита должны быть равны 0. 
 
#### 16)
Установка или сброс битов двоичного кода может быть использована, например, в задачах контроля доступа, кодирования информации, определения состояния устройств, изменения настроек и т.д 
#### 17)
Операция «исключающее или» (XOR) обладает следующими возможностями: 
 1 Замкнутость. В результате этой операции два n-битовых слова дают другое n-битовое слово. 
 2 Ассоциативность. Позволяет использовать больше чем одно «исключающее или», которые можно вычислять в любом порядке. 
 3 Коммутативность. 
Позволяет менять местами операторы (входную информацию), не изменяя результат (выходную информацию). 
 4 Существование нулевого (тождественного) элемента. Нулевой элемент для операции «исключающее или» — слово, которое состоит из всех нулей. 
 5 Существование инверсии. В поле GF(2n) каждое слово является аддитивной инверсией самого себя. 
#### 18) 
Алгоритм шифрования кода с использованием операции "исключающее ИЛИ" может быть следующим: 
- Используем случайно генерируемую ключевую маску с таким же размером, как и исходное сообщение. 
- Применяем операцию "исключающее ИЛИ" между ключевой маской и исходным сообщением. 
- Полученный результат будет зашифрованным кодом сообщения. 
- Для расшифровки нужно применить операцию "исключающее ИЛИ" между зашифрованным кодом и ключевой маской. 
####19)
 Для определения совпадают или нет биты S' и S при выполнении сложения, можно использовать операцию "исключающее ИЛИ" между этими битами. Если результат будет равен 0, значит биты совпадают, иначе они не совпадают. 
#### 20)
Операция "НЕ" играет роль при получении отрицательных чисел в представлении в дополнительном коде. Применение операции "НЕ" к числу инвертирует каждый бит числа. 
#### 21)
Для инверсии всех битов числа без использования операции "НЕ" можно применить операцию "ИСКЛЮЧАЮЩЕЕ ИЛИ" числа с маской, которая имеет все биты установлены в 1. 
#### 22)
Сдвиг — это перемещение всех битов первого операнда (байта или слова) влево или вправо на число, заданное вторым операндом. 
Существуют следующие виды сдвига: 
 1 Логический сдвиг влево (shl). 
 2 Арифметический сдвиг влево (sal). 
 3 Логический сдвиг вправо (shr). 
 4 Арифметический сдвиг вправо (sar). 
 5 Циклический сдвиг влево (rol). 
 6 Циклический сдвиг вправо (ror). 
 7 Циклический сдвиг влево через перенос (rcl). 
 8 Циклический сдвиг вправо через перенос (rcr). 
 
#### 23)
При различных типах сдвига самый старший и самый младший биты могут обрабатываться по-разному. Например, при арифметическом сдвиге вправо самый старший бит сохраняется, при логическом сдвиге вправо - самый старший бит заполняется нулем, а при циклическом сдвиге вправо - самый старший бит становится младшим. 
#### 24) 
Сдвиг влево двоичного кода удваивает число, потому что при каждом сдвиге влево каждый разряд умножается на 2. Сдвиг вправо уменьшает число вдвое, потому что при каждом сдвиге вправо каждый разряд делится на 2. 
#### 25) 
Логический сдвиг не годится для уменьшения в два раза отрицательных чисел, потому что он не сохраняет знак числа. Арифметический сдвиг, в отличие от логического, сохраняет знак числа. При арифметическом сдвиге вправо отрицательные числа уменьшаются вдвое, а при сдвиге влево увеличиваются вдвое. 
#### 26) - 
#### 27) 
Правило вычисления результата арифметического сдвига отрицательного нечётного числа на один разряд вправо следующее: 
- Каждый разряд числа сдвигается на один разряд вправо. 
- Самый старший разряд заполняется единицей, если знак числа отрицательный, иначе нулем. 
- Знак числа остается неизменным. 
Это правило применимо и к положительным нечетным числам. 
Формула упрощается для четных исходных значений, так как после арифметического сдвига четного числа на один разряд вправо, результат будет равен половине исходного числа. 
#### 28) -

### ЗАДАЧИ

#### 1) 

00011111^2 + 00010011^2 = 00110010^2 

#### 2) 

11100001^2 + 00010011^2 = 11110100^2 

#### 3) 

– 

#### 4) 

1011111^2; 11011111^2 

#### 5) 

1100^2 ⋅ 111^2 = 1010100^2 

#### 6) 

11110100^2 ⋅ 111^2 = 10101100^2 

#### 7) 

Коля  просто  догадался  применить  переместительный  закон  для  умножения,  переставив  
сомножители. 

#### 8) 

119 и 136, 119 и –120 

#### 9) 

кодЗаглавной = кодСтрочной and DF^16 

#### 10) 

кодСтрочной = кодЗаглавной or 20^16 

#### 11) 

Решение Коли приводит к неправильным ответам, когда сумма цифр больше 15. 

#### 12) 

4, 8, 16 – все они делятся нацело на 4 

#### 13) 

X and1 = 0 , X and 7 = 0 , X and F = 0 , 

#### 14) 

a:=a xor b; b:=b xor a; a:=a xor b; 

#### 15) 

R:= X shr 16; G:=(X shr 8) & F^16; B:= X & F^16; 

#### 16) 

Правильны оба решения, но у Коли рациональнее. 

#### 17) 

Y:=(X shl 4) shr 4; Z:=(X shr 4) shl 4; 1 

#### 18) 

При использовании 16‐битных данных: EDC0^16, EDCF^16.

#### 19) 

При использовании 16‐битных данных: 0123^16, 4123^16, 0123^16; 0FED^16, CFED^16, FFED^16 

#### 20) 

EE16, 7716 = 119 = (256 – 18)/2, F716 = –9 

#### 21) 

FF^16, FF^16, FF^16 

#### 22)

Z = 11002 = 12 

Z = Z shl 1 = 11000^2 

X = Z = 11000^2 

X = X shl 2 = 1100000^2 

X = X + Z = 1111000^2 = 120
